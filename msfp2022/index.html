<!DOCTYPE html>
<html lang="en-GB">
<head><meta charset="UTF-8"><meta content="width=device-width, initial-scale=1" name="viewport"><link href="https://unpkg.com/purecss@1.0.0/build/pure-min.css" rel="stylesheet"><link href="https://unpkg.com/purecss@1.0.0/build/grids-responsive-min.css" rel="stylesheet"><link href="../style.css" rel="stylesheet"><title>Mathematically Structured Functional Programming 2022</title>
</head>
<body>
<div class="pure-g main">
<div class="pure-u-1 pure-u-sm-1-5 pure-u-md-2-8 pure-u-lg-2-8"></div>
<div class="pure-u-1 pure-u-sm-4-5 pure-u-md-17-24 pure-u-lg-4-8 body">
<h1>Ninth Workshop on Mathematically Structured Functional Programming (MSFP 2022)</h1>

<p><em>Functionality from Structure</em></p>

<h2>Introduction</h2>

<p>The ninth workshop on Mathematically Structured Functional
Programming is devoted to the derivation of functionality from
structure. It is a celebration of the direct impact of Theoretical
Computer Science on programs as we write them today. Modern
programming languages, and in particular functional languages, support
the direct expression of mathematical structures, equipping
programmers with tools of remarkable power and abstraction. Where
would Haskell be without monads? Functional reactive programming
without arrows?  Call-by-push-value without adjunctions? The list goes
on. This workshop is a forum for researchers who seek to reflect
mathematical phenomena in data and control.</p>

<p>MSFP 2022 will be held on Saturday 2nd April 2022 in affiliation with <a href="https://etaps.org/2022">ETAPS 2022</a> in Munich, Germany.</p>

<h2>Proceedings</h2>

<p>The proceedings have now been published as
<a href="http://eptcs.web.cse.unsw.edu.au/content.cgi?MSFP2022">EPTCS Volume 360</a>.</p>

<!--
<p>The (preliminary) proceedings are available <a href="http://eptcs.web.cse.unsw.edu.au/content.cgi?MSFP2022">here</a> and the same link will be used for the final published proceedings.</p>
-->

<h2>Invited Speaker</h2>

<p><a href="http://vcvpaiva.github.io/">Valeria de Paiva</a>, Topos Institute, USA, <b>Going Without: A Linear Modality and its Role</b></p>
<blockquote>Linear type theories have been with us for more than 25 years, from the beginning of Linear Logic, and they still have much to teach us. I want to discuss and compare four linear type theories and show how an overlooked system has much potential to help with open issues in modal type theory. We discuss the Linear Lambda Calculus (Benton et al), Plotkin and Barber's DILL (Dual Intuitionistic Linear Logic) and Benton's Linear-non-Linear (LNL) type theories. Then we recall how DILL can be transformed into ILT (Intuitionistic and Linear Type Theory), as described by Maietti et al 2000, a type theory without a modality, but with two functions spaces, and what we gain with this transformation.  Finally, we speculate on how this transformation might be helpful for other modal type theories, their models and envisaged applications.</blockquote>

<h2>Accepted Submissions</h2>

<p><b>LIBNDT: Towards a formal library on spreadable properties over linked nested datatypes</b> (Mathieu Montin, Am√©lie Ledein and Catherine Dubois)</p>
<blockquote>Nested datatypes have been widely studied in the past 50 years, both theoretically using category theory, and practically in programming languages such as Haskell. They consist in recursive polymorphic datatypes where the type parameter changes throughout the recursion, and have a variety of applications such as modelling memory or modelling constraints over regular datatypes without relying on dependent types. In this work, we focus on a specific subset of nested datatypes which we call Linked Nested DataTypes (LNDT). We show that some usual datatypes such has List and Maybe, as well as some well-known nested datatypes such as Nest and even Bush can be built as various instances of LNDT. We proceed by presenting LIBNDT, a library, developed both in Agda and Coq, which focuses on the set of constructs that can be propagated directly from the parameter on which a LNDT is built, to the LNDT itself. These constructs are of two kinds, functions, such as folds and map, and properties, such as the congruence of map or the satisfaction of a given predicate for at least one, or all, elements of the structure. We make use of the dependent type system of both Coq and Agda to model the latter. We end by discussing several interesting topics that were raised throughout our development such as termination, comparison of our tools and the proof effort required to extend LIBNDT with additional elements.</blockquote>

<p><b>Data Types with Negation</b> (talk only) (<a href="http://bentnib.org/">Robert Atkey</a>) (<a href="atkey-abstract.pdf">extended abstract</a>) </p>
<blockquote>Inductive data types are a foundational tool for representing data and knowledge in dependently typed programming languages. The user provides a collection of rules that determine positive evidence for membership in the type. Elimination of an inductive type corresponds to structural induction on its members. But what if our data modelling requires negative information as well as positive? For example, representing the result of a backtracking parser requires evidence that a certain parsing attempt *didn't* work. Standard formulations of inductive types do not allow negative information mixed with positive. Mixing positive and negative information has been studied in logic programming, resulting in concepts like Negation as Failure, stable model semantics, and well-founded semantics. Incorporating negative information into systems of rules leads us into the realm of non-monotonic logics, where simply adding knowledge does not necessarily preserve existing conclusions. We describe a way to understand data types with negative information in type theory by combining ideas from 3-valued stable models in logic programming and constructive negation (or refutation) from linear logic.</blockquote>

<p><b>Sikkel: Multimode Simple Type Theory as an Agda Library</b> (Joris Ceulemans, Andreas Nuyts and Dominique Devriese)</p>
<blockquote>Many variants of type theory extend a basic theory with additional primitives or properties like univalence, guarded recursion or parametricity, to enable constructions or proofs that would be harder or impossible to do in the original theory. However, implementing such extended type theories (either from scratch or by modifying an existing implementation) is a big hurdle for their wider adoption. In this paper we present Sikkel, a library in the dependently typed programming language Agda that allows users to program in extended type theories. It uses a deeply embedded language that can be easily extended with additional type and term constructors, thus supporting a wide variety of type theories. Moreover, Sikkel has a type checker that is sound by construction in the sense that all well-typed programs are automatically translated to their semantics in a shallow embedding based on presheaf models. Additionally, our model supports combining different base categories by using modalities to transport definitions between them. This enables in particular a general approach for extracting definitions to the meta-level, so that we can use the extended type theories to define regular Agda functions and prove properties of them. In this paper, we demonstrate Sikkel theories with guarded recursion and parametricity, but other extensions can be easily plugged in. For now, Sikkel supports only simple type theories but its model already anticipates the future addition of dependent types and a universe.</blockquote>

<p><b>What makes a strong monad</b> (<a href="https://dylanm.org/">Dylan McDermott</a> and <a href="http://www.ru.is/faculty/tarmo">Tarmo Uustalu</a>)</p>
<blockquote>Strong monads are important for several applications, in particular, in the denotational semantics of effectful languages, where strength is needed to sequence computations that have free variables. Strength is non-trivial: it can be difficult to determine whether a monad has any strength at all, and monads can be strong in multiple ways. We therefore review some of the most important known facts about strength and prove some new ones. In particular, we present a number of equivalent characterizations of strong functor and strong monad, and give some conditions that guarantee existence or uniqueness of strengths. We look at strength from three different perspectives: actions of a monoidal category V, enrichment over V, and powering over V. We are primarily motivated by semantics of effects, but the results are also useful in other contexts.</blockquote>

<p><b>Tableless calculation of circular functions on dyadic rationals</b> (Petr Kourzanov)</p>
<blockquote>I would like to tell a story. A story about a beautiful mathematical relationship that elucidates the computational view on the classic subject of trigonometry. All stories need a language, and for this particular story an algorithmic language ought to do well. What makes a language algorithmic? From our perspective as the functional programming community, it should support expression of the computation rather than impose its own limitations on the algorithm. We develop a new algorithm for the computation of trigonometric functions on dyadic rationals, together with the language used to express it, in Scheme. We provide a mechanically-derived algorithm for the computation of the inverses of our target functions. We address efficiency and accuracy concerns that pertain to the implementation of the proposed algorithm either in hardware or software.</blockquote>

<p><b>On Structuring Functional Programs with Monoidal Profunctors</b> (Alexandre Garcia de Oliveira, Mauro Jaskelioff and Ana Cristina Vieira de Melo)</p>
<blockquote>We study monoidal profunctors as a tool to reason and structure pure functional programs both from a categorical perspective and as a Haskell implementation. From the categorical point of view we approach them as monoids in a certain monoidal category of profunctors. We study properties of this monoidal category and construct and implement the free monoidal profunctor. We study the relationship of monoidal construction to optics, and introduce a promising generalization of the implementation which we illustrate by introducing effectful monoidal profunctors.</blockquote>

<p><b>Combinatory adjoints and differentiation</b> (Martin Elsman, Fritz Henglein, Robin Kaarsgaard, Mikkel Kragh Mathiesen and Robert Schenck)</p>
<blockquote>Automatic differentiation is the discipline of computing derivatives for functions specified by programs.  It has numerous applications in machine learning, computational science, quantitative finance and more. Traditionally it is formulated based on calculus, using a dual number interpretation for scalar values. In this paper we develop a compositional approach for automatic and symbolic differentation based on and motivated by categorical constructions on structured (particularly Hilbert) vector spaces in functional analysis, where derivatives are linear maps on abstract vectors rather than being limited to scalars or tensors (vectors, matrices, higher-rank tensors) of scalar values. We show that automatic differentiation can be decomposed into unrolling a program into a term denoting an analytic function with the same derivative at a given input as the original program, symbolically differentiating the function using a differential calculus for primitive functions and general rules for constant, linear and bilinear functions as well as rules for function combinators, and finally computing the (Hermitian) adjoint of the derivative symbolically without using matrices, which are too inefficient to use for functions on high-dimensional spaces.  The resulting symbolic representation of a linear map can be interpreted as a data-parallel program ready for compilation to a modern GPU-architecture.  This turns out to be behaviorally equivalent to reverse-mode automatic differentiation, but different in not using dual (scalar) numbers.   In particular, it opens opportunities for optimization on high-dimensional functions, where matrices are too inefficient to represent linear maps. We illustrate the approach with examples from deep learning, where functions on (very) high-dimensional spaces are common.</blockquote>

<p><b>The Programming of Algebra</b> (Fritz Henglein, Mikkel Kragh Mathiesen and Robin Kaarsgaard)</p>
<blockquote>We present module theory and linear maps as a powerful generalised and computationally efficient framework for the relational data model, which underpins today‚Äôs relational database systems. Based on universal constructions of modules we obtain compact and computationally efficient data structures for data collections corresponding to union and deletion, repeated union, Cartesian product and key-indexed data. Free modules naturally give rise to polysets, which generalise multisets and facilitate expressing database queries as multilinear maps with asymptotically efficient evaluation on polyset constructors. We introduce compact maps as a way of representing infinite (poly)sets constructible from an infinite base set and its elements by addition and subtraction. We show how natural joins generalise to algebraic joins, while intersection is implemented by a novel algorithm on nested compact maps that carefully avoids visiting parts of the input that do not contribute to the eventual output. Our algebraic framework leads to a worst-case optimal evaluation of cyclic relational queries, which is known to be impossible using textbook query optimisers that operate on lists of records only.</blockquote>

<h2>Registration</h2>

Register for participation via the <a href="https://etaps.org/2022/registration">ETAPS registration page</a>. The normal registration deadline is 10th March, late deadline 26th March.

<h2>Programme</h2>

All times are <strong>UTC+2</strong> (CEST, the timezone of Munich). 
There is a <a href="https://www.youtube.com/playlist?list=PL3M2r2U7NbYlKTEX2uoKit3Qfu4f2UcD_">playlist of videos</a> on YouTube.

<p>
  <i>Contributed session 1: 10:30-12:30</i> <br>
  <strong>10:30</strong> 
  <em>Martin Elsman, Fritz Henglein, Robin Kaarsgaard, Mikkel Kragh Mathiesen and Robert Schenck</em>,
  Combinatory adjoints and differentiation (<a href="henglein.pdf">slides</a>, <a href="https://www.youtube.com/watch?v=o9z5vCAuILM.pdf">video</a>) <br>
  <strong>11:00</strong> 
  <em>Mathieu Montin, Am√©lie Ledein and Catherine Dubois</em>,
  LIBNDT: Towards a formal library on spreadable properties over linked nested datatypes (<a href="dubois.pdf">slides</a>, <a href="https://www.youtube.com/watch?v=ufqtIMg7KKI">video</a>) <br>
  <strong>11:30</strong> 
  <em>Petr Kourzanov</em>,
  Tableless calculation of circular functions on dyadic rationals (<a href="kourzanov.pdf">slides</a>, <a href="https://www.youtube.com/watch?v=LgTMwMshYzE">video</a>) <br>
  <strong>12:00</strong> 
  <em>Fritz Henglein, Mikkel Kragh Mathiesen and Robin Kaarsgaard</em>,
  The Programming of Algebra (<a href="mathiesen.pdf">slides</a>, <a href="https://www.youtube.com/watch?v=AYNPiYGBXD8">video</a>) <br>
</p>

<p>
  <i>Contributed session 2: 14:00-16:00</i> <br>
  <strong>14:00</strong> 
  <em>Robert Atkey</em>,
  Data Types with Negation (<a href="atkey.pdf">slides</a>, <a href="https://www.youtube.com/watch?v=mZZjOKWCF4A">video</a>) <br>
  <strong>14:30</strong> 
  <em>Joris Ceulemans, Andreas Nuyts and Dominique Devriese</em>,
  Sikkel: Multimode Simple Type Theory as an Agda Library (<a href="ceulemans.pdf">slides</a>, <a href="https://www.youtube.com/watch?v=WTKkFNfbEAs">video</a>) <br>
  <strong>15:00</strong> 
  <em>Dylan McDermott and Tarmo Uustalu</em>,
  What makes a strong monad (<a href="mcdermott.pdf">slides</a>, <a href="https://www.youtube.com/watch?v=M2KWbMLMHe0">video</a>) <br>
  <strong>15:30</strong> 
  <em>Alexandre Garcia de Oliveira, Mauro Jaskelioff and Ana Cristina Vieira de Melo</em>,
  On Structuring Functional Programs with Monoidal Profunctors (<a href="garcia.pdf">slides</a>, <a href="https://www.youtube.com/watch?v=ZasY1Skwp0E">video</a>) <br>
</p>

<p>
  <i>Keynote: 16:30-17:30</i> <br>
  <strong>16:30</strong> 
  <em>Valeria de Paiva</em>,
  Going Without: A Linear Modality and its Role (<a href="depaiva.pdf">slides</a>, <a href="https://www.youtube.com/watch?v=7uTsihTketw">video</a>) <br>
</p>

<h2>Call for Papers (expired)</h2>

<p>Submissions are welcomed on, but by no means restricted to, topics
such as:</p>
<ul>
  <li>structured effectful computation</li>
  <li>structured recursion</li>
  <li>structured corecursion</li>
  <li>structured tree and graph operations</li>
  <li>structured syntax with variable binding</li>
  <li>structured datatype-genericity</li>
  <li>structured search</li>
  <li>structured representations of functions</li>
  <li>structured quantum computation</li>
  <li>structure directed optimizations</li>
  <li>structured types</li>
  <li>structure derived from programs and data</li>
</ul>

<p>
  Please contact the programme
  chairs <a href="mailto:maxsnew@umich.edu">Max New</a>
  and <a href="mailto:jeremy.gibbons@cs.ox.ac.uk">Jeremy Gibbons</a>
  if you have any  questions about the scope of the workshop.
</p>

<p>We accept two categories of submission: full papers of no more than
15 pages that will appear in the proceedings, and extended abstracts
of no more than 2 pages which we will post on the website, but which
do not constitute formal publications and will not appear in the
proceedings. References and appendices are not included in page
limits. Appendices may not be read by reviewers. </p>
<p>Full papers (not two page talk abstracts) must report previously
unpublished work and not be submitted concurrently to another
conference with refereed proceedings. Accepted papers and talks must
be presented at the workshop by at least one of the authors.</p>
<p>The proceedings will be published under the auspices of
<a href="http://eptcs.org/">EPTCS</a> with a Creative Commons license. Papers
must be prepared in LaTeX using the <a href="http://style.eptcs.org/">EPTCS macro
package</a>.</p>

<p>We are using <a href="https://easychair.org/conferences/?conf=msfp2022">EasyChair</a> to manage submissions.</p>

<h3>Important Dates</h3>

<ul>
  <li>Abstract deadline:  16 December  (Thursday)</li>
  <li>Paper deadline:     23 December  (Thursday)</li>
  <li>Notification:       27 January (Thursday)</li>
  <li>Final version:      24 February    (Thursday)</li>
  <li>Workshop:           2 April    (Saturday)</li>
</ul>

<h3>Programme Committee</h3>

<ul>
  <li><a href="https://www.cs.uni-potsdam.de/~brede/">Nuria Brede</a> - University of Potsdam, Germany</li>
  <li><a href="https://www.cas.mcmaster.ca/~carette/">Jacques Carette</a> - McMaster University, Canada</li>
  <li><a href="https://prg.is.titech.ac.jp/people/cong/">Youyou Cong</a> - Tokyo Institute of Technology, Japan</li>
  <li><a href="https://flippac.org/">Philippa Cowderoy</a> </li>
  <li><a href="https://jfdm.github.io/">Jan de Muijnck-Hughes</a> - University of Glasgow, UK</li>
  <li><a href="https://metatheorem.org/">Harley Eades III</a> - Augusta University, USA</li>
  <li><a href="https://www.cs.ox.ac.uk/people/jeremy.gibbons/">Jeremy Gibbons</a> - University of Oxford, UK (co-chair)</li>
  <li><a href="https://julesh.com/">Jules Hedges</a> - University of Stratchclyde, UK</li>
  <li><a href="https://group-mmm.org/~s-katsumata/index-e.html">Shin-Ya Katsumata</a>- National Institute of Informatics, Japan</li>
  <li><a href="http://maxsnew.com/">Max New</a> - University of Michigan, USA (co-chair)</li>
  <li><a href="https://maciejpirog.github.io/">Maciej Pir√≥g</a> - University of Wroc≈Çaw, Poland</li>
  <li><a href="http://ashinkarov.github.io/">Artjoms Sinkarovs</a> - Heriot-Watt University, UK</li>
</ul>

<h2>Previous MSFP Workshops</h2>

<h3>MSFP 2020</h3>
<p>The <a href="https://msfp-workshop.github.io/msfp2020/">eighth MSFP
Workshop</a> was held online in August 2020, originally planned as part of ETAPS. It
was organised by Sam Lindley and Max New, and featured invited
talks by Pierre-Marie Pedrot and Satnam Singh. The proceedings were
published by
EPTCS <a href="http://eptcs.web.cse.unsw.edu.au/content.cgi?MSFP2020">available
here</a>.</p>


<h3>MSFP 2018</h3>
<p>The <a href="https://msfp-workshop.github.io/msfp2018">seventh MSFP
Workshop</a> was held in July 2018, in Oxford, UK, as part of FLoC. It
was organised by Robert Atkey and Sam Lindley, and featured invited
talks by Tamara von Glehn and Didier R√©my. The proceedings were
published by
EPTCS <a href="http://eptcs.web.cse.unsw.edu.au/content.cgi?MSFP2018">available
here</a>.</p>

<h3>MSFP 2016</h3>
<p>The <a href="https://msfp-workshop.github.io/msfp2016">sixth MSFP Workshop</a>
was held in April 2016, in Eindhoven, Netherlands, just after ETAPS
2016. It was organised by Neelakantan Krishnaswami and Robert Atkey,
and featured an invited talk by Fredrik Nordvall Forsberg. The
proceedings wer published by
EPTCS <a href="http://eptcs.web.cse.unsw.edu.au/content.cgi?MSFP2016">available
here</a>.</p>

<h3>MSFP 2014</h3>
<p>The <a href="http://www.cs.bham.ac.uk/~pbl/msfp2014/">fifth MSFP Workshop</a> was
held in April 2014, in Grenoble, France, just after ETAPS 2014. It was
organised by Paul Levy and Neelakantan Krishnaswami, and
featured invited talks from Robert Atkey and Shin-ya Katsumata. The
proceedings were published by EPTCS,
<a href="http://eptcs.web.cse.unsw.edu.au/content.cgi?MSFP2014">available here</a>.</p>

<h3>MSFP 2012</h3>
<p>The <a href="http://cs.ioc.ee/msfp/msfp2012/">fourth MSFP Workshop</a> was held
in March 2012, in Tallinn, Estonia, before ETAPS 2012. It was
organized by James Chapman and Paul Levy, and featured invited talks
from Danko Ilik and Neil Ghani. The proceedings were published by
EPTCS,
<a href="http://rvg.web.cse.unsw.edu.au/eptcs/content.cgi?MSFP2012">available here</a>.</p>

<h3>MSFP 2010</h3>
<p>The <a href="http://cs.ioc.ee/msfp/msfp2010/">third MSFP Workshop</a> was held in
September 2010, in Baltimore, Maryland, before ICFP 2010. It was
organized by Venanzio Capretta and James Chapman, and featured invited
talks from Mart√≠n Escard√≥ and Amy Felty. The proceedings were
published by ACM Press,
<a href="http://portal.acm.org/citation.cfm?id=1863597">available here</a>.</p>

<h3>MSFP 2008</h3>
<p>The <a href="http://cs.ioc.ee/msfp/msfp2008/">second MSFP Workshop</a> was held
in July 2008, at Reykjavik University, Iceland as part of
ICALP 2008. It was organized by Conor McBride and Venanzio Capretta,
and featured invited talks from Andrej Bauer and Dan Piponi. The
proceedings were published in Electronic Notes in Theoretical Computer
Science, v. 229, n. 5,
<a href="http://www.sciencedirect.com/science/journal/15710661/229/5">available here</a>.</p>

<h3>MSFP 2006</h3>
<p>The <a href="http://www.cs.ioc.ee/mpc-amast06/msfp/">inaugural MSFP
Workshop</a> was held in July 2006, in Kuressaare, Estonia, a fine
curtain-raiser for MPC and AMAST. It was organized by Tarmo Uustalu
and Conor McBride, and featured invited talks from John Power and
Andrzej Filinski. The proceedings were published in the British
Computer Society's "Electronic Workshops in Computing" Series,
<a href="https://www.scienceopen.com/document/read?vid=06fe6a37-ed2a-47fd-ba5e-f150d546dd9d">available here</a>.</p><p>Revised selected papers (with a full re-refereeing process) appeared
as a special issue of the
<a href="https://www.cambridge.org/core/journals/journal-of-functional-programming/issue/15F600B0D2E584C392A306701B2448D3">Journal of Functional Programming Volume 19 Issue 3-4</a>.</p>

</div>
<div class="pure-u-1 pure-u-sm-1-5 pure-u-md-1-24 pure-u-lg-2-8"></div>
</div>
</body>
</html>
